from collections import defaultdict
from dataclasses import dataclass
from textwrap import indent
from typing import List, Iterator, Collection, Iterable, Dict

import click

from sebex.analysis import Version, AnalysisDatabase, DependentsGraph
from sebex.analysis.version import Bump, UnsolvableBump
from sebex.checksum import Checksum
from sebex.config import ProjectHandle, ConfigFile
from sebex.config.format import Format, YamlFormat
from sebex.log import operation, error


@dataclass
class ReleaseState(ConfigFile):
    _name = 'release'

    sources: Dict[ProjectHandle, Version]
    phases: List['PhaseState']

    def __init__(self, name=None, data=None, sources=None, phases=None):
        self.sources = sources
        self.phases = phases

        super().__init__(name, data)

    def _load_data(self, data):
        if data is not None:
            self.sources = {ProjectHandle.parse(p): Version.parse(v)
                            for p, v in data['release'].items()}
            self.phases = [PhaseState.from_raw(p) for p in data['phases']]

    def _make_data(self):
        return {
            'release': {str(p): str(v) for p, v in self.sources.items()},
            'phases': [p.to_raw() for p in self.phases]
        }

    @classmethod
    def format(cls) -> Format:
        return YamlFormat(autogenerated=True)

    def codename(self) -> str:
        return Checksum.of(self).petname

    def has_project(self, project: ProjectHandle) -> bool:
        for phase in self.phases:
            if phase.has_project(project):
                return True

        return False

    def get_project(self, project: ProjectHandle) -> 'ProjectReleaseState':
        for phase in self.phases:
            if phase.has_project(project):
                return phase.get_project(project)

        raise KeyError(f'Project {project} is not part of this release.')

    def describe(self) -> str:
        header = f'Release "{self.codename()}"'
        txt = f'{header}\n{"=" * len(header)}\n\n'

        for i, phase in enumerate(self.phases, start=1):
            txt += f'{i}. {phase.describe()}'

        return txt

    @classmethod
    def plan(cls, project: ProjectHandle, to_version: Version,
             db: AnalysisDatabase, graph: DependentsGraph) -> 'ReleaseState':
        with operation('Constructing release plan'):
            about_project = db.about(project)
            from_version = about_project.version

            if from_version == to_version:
                # We are not releasing anything at all.
                return cls(sources={}, phases=[])
            elif from_version > to_version:
                # We are backporting bug fixes to older releases than the current one.
                raise NotImplementedError('backports are not implemented yet')
            else:
                # We are making a brand-new release
                sources = {project: to_version}

                phases = graph.upgrade_phases(about_project.package)
                phases = (
                    (db.get_project_by_package(pkg) for pkg in sorted(phase))
                    for phase in phases
                )
                phases = [PhaseState.clean(projs, db) for projs in phases]
                assert len(phases) > 0

                rel = cls(sources=sources, phases=phases)

                # Seed the release with initial project
                rel.get_project(project).to_version = to_version

                rel._solve_bumps(db, graph)
                return rel

    def _solve_bumps(self, db: AnalysisDatabase, graph: DependentsGraph):
        """
        Propagate version bumps down the phases, we are searching for
        maximum needed bump for each project.
        """

        bumps = defaultdict(lambda: Bump.STAY_AS_IS)

        for handle in self.sources.keys():
            project = self.get_project(handle)
            bumps[handle] = Bump.between(project.from_version, project.to_version)
            assert bumps[handle] != Bump.STAY_AS_IS

        for phase in self.phases:
            for proj in phase:
                for dep_pkg in graph.dependents_of(db.about(proj.project).package):
                    dep = db.get_project_by_package(dep_pkg)
                    dep_bump = bumps[proj.project].derive(proj.from_version)
                    bumps[dep] = max(bumps[dep], dep_bump)

        # Verify that all bumps are possible
        invalid_bumps = False
        for project, bump in bumps.items():
            if bump == Bump.UNSOLVABLE:
                error('Unable to bump project', project)
                invalid_bumps = True
        if invalid_bumps:
            raise UnsolvableBump()

        # Apply found version bumps to projects
        for phase in self.phases:
            for proj in phase:
                if proj.project in self.sources:
                    proj.to_version = self.sources[proj.project]
                else:
                    proj.to_version = bumps[proj.project].apply(proj.from_version)


@dataclass
class PhaseState(Collection['ProjectReleaseState']):
    _items: List['ProjectReleaseState']

    def __len__(self) -> int:
        return len(self._items)

    def __iter__(self) -> Iterator['ProjectReleaseState']:
        return iter(self._items)

    def __contains__(self, item) -> bool:
        return item in self._items

    def codename(self) -> str:
        return Checksum.of(self).petname

    def has_project(self, project: ProjectHandle) -> bool:
        for prs in self._items:
            if prs.project == project:
                return True

        return False

    def get_project(self, project: ProjectHandle) -> 'ProjectReleaseState':
        for prs in self._items:
            if prs.project == project:
                return prs

        raise KeyError(f'This phase does not include project {project}')

    def describe(self) -> str:
        header = f'Phase "{self.codename()}"'
        txt = f'{header}\n'

        for proj in sorted(self._items, key=lambda p: p.project):
            descr = '  * ' + indent(proj.describe(), '    ')[4:]
            txt += f'{descr}\n'

        return txt

    @classmethod
    def clean(cls, projects: Iterable[ProjectHandle], db: AnalysisDatabase) -> 'PhaseState':
        return PhaseState([ProjectReleaseState.clean(proj, db) for proj in projects])

    def to_raw(self) -> Dict:
        return {
            'projects': [p.to_raw() for p in self._items],
        }

    @classmethod
    def from_raw(cls, o: Dict) -> 'PhaseState':
        return cls([ProjectReleaseState.from_raw(p) for p in o['projects']])


@dataclass
class ProjectReleaseState:
    project: ProjectHandle
    from_version: Version
    to_version: Version

    @property
    def bump(self) -> Bump:
        return Bump.between(self.from_version, self.to_version)

    def describe(self) -> str:
        from_version = click.style(str(self.from_version), fg="cyan")
        to_version = click.style(str(self.to_version), fg=_bump_color(self.bump))
        return f'{self.project}, {from_version} -> {to_version}'

    @classmethod
    def clean(cls, project: ProjectHandle, db: AnalysisDatabase) -> 'ProjectReleaseState':
        about = db.about(project)
        return cls(
            project=project,
            from_version=about.version,
            to_version=about.version
        )

    def to_raw(self) -> Dict:
        return {
            "project": str(self.project),
            "from_version": str(self.from_version),
            "to_version": str(self.to_version),
        }

    @classmethod
    def from_raw(cls, o: Dict) -> 'ProjectReleaseState':
        return cls(
            project=ProjectHandle.parse(o['project']),
            from_version=Version.parse(o['from_version']),
            to_version=Version.parse(o['to_version']),
        )


def _bump_color(bump: Bump) -> str:
    if bump in [Bump.STAY_AS_IS, Bump.PATCH]:
        return 'cyan'
    elif bump == Bump.MINOR:
        return 'green'
    elif bump == Bump.MAJOR:
        return 'yellow'
    else:
        return 'red'
